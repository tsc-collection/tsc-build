# vim:ft=jam
#
#            Tone Software Corporation BSD License ("License")
# 
#                        Software Build Environment
#                        
# Please read this License carefully before downloading this software. By
# downloading or using this software, you are agreeing to be bound by the
# terms of this License. If you do not or cannot agree to the terms of
# this License, please do not download or use the software.
# 
# A set of Jam configuration files and a Jam front-end for advanced
# software building with automatic dependency checking for the whole
# project. Provides a hierarchical project description while performing
# build procedures without changing directories. The resulting domain
# language changes emphasis from how to build to what to build. Provides
# separation of compilation artifacts (object files, binaries,
# intermediate files) from the original sources. Comes standard with
# ability to build programs, test suites, static and shared libraries,
# shared modules, code generation, and many others. Provides the bridge to
# ANT for building Java, with abilities to build JNI libraries.
# 
# Copyright (c) 2003, 2005, Tone Software Corporation
# 
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#   * Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer. 
#   * Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution. 
#   * Neither the name of the Tone Software Corporation nor the names of
#     its contributors may be used to endorse or promote products derived
#     from this software without specific prior written permission. 
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# 

actions together action.compile-cc
{
  path_list = [ '$(COMPILE_PATH_LIST)', ]
  ENV['PATH'] = [ path_list, ENV['PATH'] ].flatten.compact.join(File::PATH_SEPARATOR) unless path_list.empty?

  exec *[ '$(CXX)', '$(CXX_COMPILE_ONLY_FLAG)', '$(CXX_FLAGS)', '$(TARGET_FLAGS)', '$(CXX_DEFINE_FLAG)$(DEFINES)', '$(CXX_DEFINE_FLAG)$(TARGET_DEFINES)', '$(CXX_INCLUDE_FLAG_BEFORE)$(INCLUDES)', '$(CXX_INCLUDE_FLAG)$(TARGET_INCLUDES)', '$(CXX_INCLUDE_FLAG)$(>:D)', '$(CXX_INCLUDE_FLAG_AFTER)$(INCLUDES)', '$(CXX_TARGET_NAME_FLAG_STANDALONE)', '$(CXX_TARGET_NAME_FLAG_ATTACHED)$(<)', '$(TARGET_BINARY_SOURCE:E=$(>))' ]
}

actions together action.compile-c
{
  path_list = [ '$(COMPILE_PATH_LIST)', ]
  ENV['PATH'] = [ path_list, ENV['PATH'] ].flatten.compact.join(File::PATH_SEPARATOR) unless path_list.empty?

  exec *[ '$(CC)', '$(CC_COMPILE_ONLY_FLAG)', '$(CC_FLAGS)', '$(TARGET_FLAGS)', '$(CC_DEFINE_FLAG)$(DEFINES)', '$(CC_DEFINE_FLAG)$(TARGET_DEFINES)', '$(CC_INCLUDE_FLAG_BEFORE)$(INCLUDES)', '$(CC_INCLUDE_FLAG)$(TARGET_INCLUDES)', '$(CC_INCLUDE_FLAG)$(>:D)', '$(CC_INCLUDE_FLAG_AFTER)$(INCLUDES)', '$(CC_TARGET_NAME_FLAG_STANDALONE)', '$(CC_TARGET_NAME_FLAG_ATTACHED)$(<)', '$(TARGET_BINARY_SOURCE:E=$(>))' ]
}

actions together action.compile-resource
{
  path_list = [ '$(COMPILE_PATH_LIST)', ]
  ENV['PATH'] = [ path_list, ENV['PATH'] ].flatten.compact.join(File::PATH_SEPARATOR) unless path_list.empty?

  exec *[ '$(RC)', '$(RC_FLAGS)', '$(TARGET_FLAGS)', '$(CC_DEFINE_FLAG)$(DEFINES)', '$(CC_DEFINE_FLAG)$(TARGET_DEFINES)', '$(CC_INCLUDE_FLAG_BEFORE)$(INCLUDES)', '$(CC_INCLUDE_FLAG)$(TARGET_INCLUDES)', '$(CC_INCLUDE_FLAG)$(>:D)', '$(CC_INCLUDE_FLAG_AFTER)$(INCLUDES)', '$(CC_TARGET_NAME_FLAG_STANDALONE)', '$(CC_TARGET_NAME_FLAG_ATTACHED)$(<)', '$(TARGET_BINARY_SOURCE:E=$(>))' ]
}

actions together action.generate-build-file
{
  rm_f Dir['$(>[1]:S=).*.c'.gsub('\\', '/')]
  open('$(<[1])', 'w').puts 'const char * const __TSC_BUILD__ = "@(#)build $(PRODUCT_BUILD) of $(PRODUCT_NAME) ($(PRODUCT_TAG)) $(PRODUCT_RELEASE) for $(PRODUCT_PLATFORM) by $(USER) ";'
}

actions together action.reloc
{
  open('$(<)', 'w').puts %w[ $(CONTENT) ]
}

# For the next 2 actions: on Windows, $(core.TOPDIR) ends with \. Ruby
# interprets it as the quoting for the next character and leaves that 
# character in the resulting string. Hence the trick -- we cannot use
# '$(core.TOPDIR)', as the last single quote will be quoted by the last
# back slash in core.TOPDIR; using extra spaces around and immediatelly 
# removing them with String#strip.
#
actions together action.shared-library
{
  path_list = [ '$(COMPILE_PATH_LIST)', ]
  ENV['PATH'] = [ path_list, ENV['PATH'] ].flatten.compact.join(File::PATH_SEPARATOR) unless path_list.empty?

  rm_f Dir[ '$(<:S=).[0-9]*'.gsub('\\', '/') ]
  system *[ '$(LINKER)', '$(DLL_FLAGS)', '$(DLL_LINKER_FLAGS)', '$(LINKER_FLAGS)', '$(TARGET_FLAGS)', '$(DLL_SONAME_FLAG)$(TARGET_SONAME)', '$(LINKER_IMPLIB_NAME_FLAG)$(TARGET_IMPLIB)', '$(LINKER_LIBDIR_FLAG)$(LIBDIRS)', '$(LINKER_LIBDIR_FLAG)$(TARGET_LIBDIRS)', '$(LINKER_LIB_FLAG)$(LIBS)$(LINKER_LIB_SUFFIX)', '$(LINKER_LIB_FLAG)$(SYSLIBS)$(LINKER_LIB_SUFFIX)', '$(LINKER_LIB_FLAG)$(TARGET_LIBS)$(LINKER_LIB_SUFFIX)', '$(LINKER_LIB_FLAG)$(TARGET_SYSLIBS)$(LINKER_LIB_SUFFIX)', '$(LINKER_TARGET_NAME_FLAG_STANDALONE)', '$(LINKER_TARGET_NAME_FLAG_ATTACHED)$(<)', '$(EXTRA_OBJECTS)', *%w[ $(TARGET_OBJECTS) ].map { |item| %w[ $(MERGE) ].empty? ? item : IO.readlines(item).map { |object| ' $(core.TOPDIR) '.strip + object.chomp } }.flatten ] or raise 'Command failed'
  status = $?
  rm_f "so_locations"
  raise "Command failed" unless status.success?
}

actions action.shared-library-exports
{
  touch ' $(<) '.split
}

actions action.polish-dll
{
  touch ' $(<) '.split
}

actions action.polish-program
{
  touch ' $(<) '.split
}

actions action.import-library
{
  touch ' $(<) '.split
}

# See the above note.
#
actions together action.static-library
{
  path_list = [ '$(COMPILE_PATH_LIST)', ]
  ENV['PATH'] = [ path_list, ENV['PATH'] ].flatten.compact.join(File::PATH_SEPARATOR) unless path_list.empty?

  rm_f [ '$(<)', ]
  exec *[ '$(AR)', '$(AR_TARGET_NAME_FLAG)$(<)', *%w[ $(>) ].map { |item| %w[ $(MERGE) ].empty? ? item : IO.readlines(item).map { |object| ' $(core.TOPDIR) '.strip + object.chomp } }.flatten ]
}

actions action.ranlib
{
  exec *[ '$(RANLIB)', '$(<)' ]
}

actions together action.shared-module
{
  path_list = [ '$(COMPILE_PATH_LIST)', ]
  ENV['PATH'] = [ path_list, ENV['PATH'] ].flatten.compact.join(File::PATH_SEPARATOR) unless path_list.empty?

  exec *[ '$(LINKER)', '$(DLL_FLAGS)', '$(DLL_LINKER_FLAGS)', '$(LINKER_FLAGS)', '$(TARGET_FLAGS)', '$(LINKER_TARGET_NAME_FLAG_STANDALONE)', '$(LINKER_TARGET_NAME_FLAG_ATTACHED)$(<)', '$(>)', '$(EXTRA_OBJECTS)', '$(LINKER_LIBDIR_FLAG)$(LIBDIRS)', '$(LINKER_LIBDIR_FLAG)$(TARGET_LIBDIRS)', '$(LINKER_LIB_FLAG)$(TARGET_LIBS)$(LINKER_LIB_SUFFIX)', '$(LINKER_LIB_FLAG)$(LIBS)$(LINKER_LIB_SUFFIX)', '$(LINKER_LIB_FLAG)$(TARGET_SYSLIBS)$(LINKER_LIB_SUFFIX)', '$(LINKER_LIB_FLAG)$(SYSLIBS)$(LINKER_LIB_SUFFIX)', ]
}

actions action.link
{
  path_list = [ '$(COMPILE_PATH_LIST)', ]
  ENV['PATH'] = [ path_list, ENV['PATH'] ].flatten.compact.join(File::PATH_SEPARATOR) unless path_list.empty?

  exec *[ '$(LINKER)', '$(EXE_LINKER_FLAGS)', '$(LINKER_FLAGS)', '$(TARGET_FLAGS)', '$(LINKER_TARGET_NAME_FLAG_STANDALONE)', '$(LINKER_TARGET_NAME_FLAG_ATTACHED)$(<)', '$(TARGET_OBJECTS)', '$(EXTRA_OBJECTS)', '$(LINKER_LIBDIR_FLAG)$(LIBDIRS)', '$(LINKER_LIBDIR_FLAG)$(TARGET_LIBDIRS_$(>))', '$(LINKER_LIBDIR_FLAG)$(TARGET_LIBDIRS)', '$(LINKER_LIB_FLAG)$(TARGET_LIBS_$(>))$(LINKER_LIB_SUFFIX)', '$(LINKER_LIB_FLAG)$(TARGET_LIBS)$(LINKER_LIB_SUFFIX)', '$(HACK_DOUBLE_LIBS)$(LINKER_LIB_FLAG)$(TARGET_LIBS)$(LINKER_LIB_SUFFIX)', '$(LINKER_LIB_FLAG)$(LIBS)$(LINKER_LIB_SUFFIX)', '$(LINKER_LIB_FLAG)$(TARGET_SYSLIBS)$(LINKER_LIB_SUFFIX)', '$(LINKER_LIB_FLAG)$(SYSLIBS)$(LINKER_LIB_SUFFIX)', '$(STATIC_LIBS)',  ]
}

actions action.print-library-path
{
  puts ' $(LD_LIBRARY_PATH) '.strip
}

actions action.invoke
{
  %w[ $(system.ENV_EXPORT_LIST) RUBY=$(RUBY) ].each { |item|
    key, value = item.split('=')
    ENV[key] = value
  }
  ENV['LD_LIBRARY_PATH'] = '$(LD_LIBRARY_PATH-$(>))'
  ENV['SHLIB_PATH'] = '$(LD_LIBRARY_PATH-$(>))'
  ENV['PATH'] = ENV['PATH'] + ':' + '$(LD_LIBRARY_PATH-$(>))'
  ENV['JAM_SRCDIR'] = '$(SRCDIR)'

  mkdir_p '$(BINDIR)'
  cd '$(BINDIR)' do
    exec %q[ $(RUNEXEC) $(COMMAND-$(>)) $(RUNARGS) $(ARGS-$(>)) ]
  end
}

actions action.invoke-ant
{
  cd $(SRCDIR) && {
    $(system.ENV_EXPORT_LIST) \
    LD_LIBRARY_PATH=$(LD_LIBRARY_PATH) \
    CLASSPATH=$(CLASSPATH) \
    JAVA_HOME=$(project.JAVA_HOME) \
    ANT_OPTS=$(ANT_JAVA_OPTIONS) \
      ant -f $(ANT_BUILD_FILE) $(ANTFLAGS) -Dsrcdir=. -Dbindir=$(BINDIR_FROM_SRCDIR) -Dgendir=$(GENDIR_FROM_SRCDIR) $(ACTION)
  }
}

actions together action.make-directory
{
  mkdir_p %w[ $(<) ]
}

actions existing together action.remove
{
  rm_rf %w[ $(>) ]
}

actions together action.cleanup-for
{
  rm_rf %w[ $(CLEANUP_LIST) ]
}

actions action.symlink
{
  rm_rf %w[ $(<) ]

  begin
    ln_sf '$(>)', '$(<)' 
  rescue NotImplementedError
    cp '$(<:D)/$(>)', '$(<)'
  end
}

actions together action.touch
{
  touch ' $(<) '.split
}

actions action.empty-c-source
{
  rm_f '$(<)'
  open('$(<)', 'w').puts '#include <stdio.h>'
}

actions together action.generate-cc-lex
{
  flex++ -S$(FLEX_SKELETON) -t $(>[1]) > $(<[1]) && {
    echo ',s/yyFlexLexer/$(CLASS_NAME)/g
    w
    q' | ed - $(<[1])
    echo 'g/<FlexLexer[.]h>/d
    w
    q' | ed - $(<[1])
    true
  }
}

actions together action.generate-cc-yacc
{
  bison -o $(<[1]) -b $(CLASS_NAME) -p_$(CLASS_NAME)_yy $(>[1]) && {
    echo ',s/yyparse/yyPARSE/g
    w
    q' | ed - $(<[1])
    echo ',s/yylex/yyLEX/g
    w
    q' | ed - $(<[1])
    echo ',s/yyerror/yyERROR/g
    w
    q' | ed - $(<[1])
    echo ',s/^yyPARSE/$(CLASS_NAME)::yyparse/g
    w
    q' | ed - $(<[1])
    echo ',s/_$(CLASS_NAME)_yyLEX/$(CLASS_NAME)::nextToken/g
    w
    q' | ed - $(<[1])
    echo ',s/_$(CLASS_NAME)_yyERROR/$(CLASS_NAME)::yyerror/g
    w
    q' | ed - $(<[1])
    true
  }
}

actions together action.generate-cc-proc
{
  ORACLE_HOME=$(ORACLE_HOME) LD_LIBRARY_PATH=$(ORACLE_HOME)$(jam.SEPARATOR)lib $(PROCC) $(PROCCFLAGS) $(PROCC_INCLUDES) iname=$(>) oname=$(<) | sed -n '/[Ee]rror/,$p'
}

actions together action.merge-generated-code
{
  for f in $(GENERATED_CODE_LIST) $(GENERATED_CODE_LIST_MAIN) ; do
    test -f ${f} && {
      echo '#line 1 "'${f}'"' | cat - ${f}
    }
  done > $(<[1])
  test -s $(<[1])
}

actions together action.generate-cc-eruby
{
  $(ECHO) '#line 1 "$(>)"' | cat - $(>) | (cd $(>:D) && eruby)  > $(<)
}

actions action.create-jni-header
{
  javah -force -jni -classpath $(BINDIR)$(jam.SEPARATOR)classes -d $(<:D) $(>)
}

actions together action.install
{
  %w[ $(system.ENV_EXPORT_LIST) ].each { |item|
    key, value = item.split('=')
    ENV[key] = value
  }
  exec %q[ $(INSTALL_LAUNCHER) distributor --source $(system.SRCTOPDIR) --binary $(system.BINTOPDIR) -i -r$(project.DISTRIB_ENV) -m$(project.DISTRIB_MODE) -p$(project.LIB_PREFIX) -l$(project.LIB_MAJOR) -P$(PRODUCT_ID) -V$(PRODUCT_RELEASE) -B$(PRODUCT_BUILD) -T$(PRODUCT_TAG) -E$(jam.DSO_EXTENTION) $(project.DISTRIB_PRODINFO) $(TARGET_DIRS) ]
}

actions together action.invoke-package-test
{
  %w[ $(system.ENV_EXPORT_LIST) ].each { |item|
    key, value = item.split('=')
    ENV[key] = value
  }
  exec %q[ $(INSTALL_LAUNCHER) distributor -t -r$(2) -- $(UNIT_TEST_ARGS) ]
}

actions together action.invoke-ruby
{
  %w[ $(system.ENV_EXPORT_LIST) ].each { |item|
    key, value = item.split('=')
    ENV[key] = value
  }
  exec %Q[ $(RUBY) -I$(PATH) -I$(LOADPATH) -rubygems $(2:1) $(ARGUMENTS) ]
}

actions together action.invoke-ruby-specs
{
  %w[ $(system.ENV_EXPORT_LIST) ].each { |item|
    key, value = item.split('=')
    ENV[key] = value
  }
  require 'sk/file-locator.rb'
  exec %Q[ $(RUBY) -I$(LOADPATH) -I$(PATH) -rubygems -S spec --require sk/spec/config $(ARGUMENTS) $(RUNARGS) #{SK::FileLocator.new("$(2)").find_bottom_up("*[_-]spec.rb").join(' ')} ]
}

actions action.package
{
  %w[ $(system.ENV_EXPORT_LIST) ].each { |item|
    key, value = item.split('=')
    ENV[key] = value
  }
  exec %q[ distributor --source $(system.SRCTOPDIR) --binary $(system.BINTOPDIR) --output $(system.PKGTOPDIR) -m$(project.DISTRIB_MODE) -p$(project.LIB_PREFIX) -l$(project.LIB_MAJOR) -P$(PRODUCT_ID) -V$(PRODUCT_RELEASE) -B$(PRODUCT_BUILD) -T$(PRODUCT_TAG) -E$(jam.DSO_EXTENTION) $(project.DISTRIB_PRODINFO) $(jam.PACKAGES) ]
}

actions action.handoff
{
  handoff -p $(project.HANDOFF_PRODUCT) -s$(project.HANDOFF_SERVER) -m$(project.HANDOFF_RECEPIENTS) 
}

actions action.generate-swig-interface
{

  File.open('$(1)', 'wb') { |output|
    %w[ $(2) ].each do |input|
      output.puts IO.readlines(input)
    end

    %w[ $(CLASS_INTERFACES:D=) ].each do |item|
      output.puts %Q{%include #{item.inspect}}
    end
  }
}

actions action.swig-java
{
  exec *[ '$(SWIG:E=swig)', '-w362', '-w401', '-w509', '-w314', '-w801', '-Werror', '-c++', '-module', '$(MODULE)', '-java', '-package', '$(PACKAGE)', '-outdir', '$(JAVA_LOCATION)', '-o', '$(1)', '-I$(INCLUDES)', '-I$(TARGET_INCLUDES)', '$(2)' ]
}

actions action.swig-ruby
{
  exec *[ '$(SWIG:E=swig)', '-w362', '-w401', '-w509', '-w314', '-w801', '-Werror', '-c++', '-ruby', '-o', '$(1)', '-I$(INCLUDES)', '-I$(TARGET_INCLUDES)', '$(2)' ]
}

actions action.generate-c-includes
{
  File.open('$(1)', 'wb') { |output|
    %w[ $(2:D=) ].each do |input|
      output.puts %Q{#include #{input.inspect}}
    end
  }
}

actions action.uudecode
{
  rm_f '$(<)'
  File.open('$(<)', 'wb') { |output|
    File.open('$(>)') { |input|
      input.each do |line|
        next if line =~ %r{^#}
        next if line =~ %r{^begin}

        output.write line.chomp.unpack('u').first
      end
    }
  }
}
